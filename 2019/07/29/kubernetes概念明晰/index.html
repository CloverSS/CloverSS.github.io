<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>kubernetes概念明晰 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Kubernetes简介从容器技术开始​    容器是一种轻量级、可移植、自包含的软件打包技术。以docker为例，Docker可以将几乎任何应用程序及其依赖的运行环境都打包成一个容器，并能够运行于支持Docker容器引擎的所有操作系统之上。Docker本身常适合用于管理单个容器，然而真正的生产型应用会涉及多个容器，这些容器必须跨多个服务器主机进行部署。于是，以Kubernetes为代表的容器编排">
<meta name="keywords" content="kubernetes">
<meta property="og:type" content="article">
<meta property="og:title" content="kubernetes概念明晰">
<meta property="og:url" content="http://yoursite.com/2019/07/29/kubernetes概念明晰/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Kubernetes简介从容器技术开始​    容器是一种轻量级、可移植、自包含的软件打包技术。以docker为例，Docker可以将几乎任何应用程序及其依赖的运行环境都打包成一个容器，并能够运行于支持Docker容器引擎的所有操作系统之上。Docker本身常适合用于管理单个容器，然而真正的生产型应用会涉及多个容器，这些容器必须跨多个服务器主机进行部署。于是，以Kubernetes为代表的容器编排">
<meta property="og:locale" content="default">
<meta property="og:image" content="c:/Users/licr/AppData/Roaming/Typora/typora-user-images/1563447759383.png">
<meta property="og:updated_time" content="2019-07-29T14:20:53.490Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kubernetes概念明晰">
<meta name="twitter:description" content="Kubernetes简介从容器技术开始​    容器是一种轻量级、可移植、自包含的软件打包技术。以docker为例，Docker可以将几乎任何应用程序及其依赖的运行环境都打包成一个容器，并能够运行于支持Docker容器引擎的所有操作系统之上。Docker本身常适合用于管理单个容器，然而真正的生产型应用会涉及多个容器，这些容器必须跨多个服务器主机进行部署。于是，以Kubernetes为代表的容器编排">
<meta name="twitter:image" content="c:/Users/licr/AppData/Roaming/Typora/typora-user-images/1563447759383.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-kubernetes概念明晰" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/kubernetes概念明晰/" class="article-date">
  <time datetime="2019-07-29T14:14:35.000Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      kubernetes概念明晰
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="从容器技术开始"><a href="#从容器技术开始" class="headerlink" title="从容器技术开始"></a>从容器技术开始</h3><p>​    容器是一种轻量级、可移植、自包含的软件打包技术。以docker为例，Docker可以将几乎任何应用程序及其依赖的运行环境都打包成一个容器，并能够运行于支持Docker容器引擎的所有操作系统之上。Docker本身常适合用于管理单个容器，然而真正的生产型应用会涉及多个容器，这些容器必须跨多个服务器主机进行部署。于是，以Kubernetes为代表的容器编排系统应运而生。</p>
<h3 id="kubernetes概述"><a href="#kubernetes概述" class="headerlink" title="kubernetes概述"></a>kubernetes概述</h3><p>​    Kubernetes的开发和设计深受Borg的影响，Borg  是Google内部使用的大规模集群管理系统。Kubernetes可以提供所需的编排和管理功能，以便用户针对这些工作负载轻松完成大规模容器部署。并且，借助于Kubernetes的编排功能，用户可以构建出跨多个容器的应用服务，并且可以实现跨集群调度、扩展容器，以及长期持续管理这些容器的健康状况等。使用中，Kubernetes还需要与网络、存储、安全性、监控及其他服务进行整合，以提供全面的容器基础架构。</p>
<p>kubernetes特性：</p>
<ol>
<li>自动化容器的部署和复制</li>
<li>随时扩展或收缩容器规模</li>
<li>服务发现和负载均衡</li>
<li>自动发布和回滚</li>
<li>密钥和配置管理</li>
<li>存储编排</li>
</ol>
<h2 id="系统组件"><a href="#系统组件" class="headerlink" title="系统组件"></a>系统组件</h2><p>​    一个典型的Kubernetes集群由多个工作节点（worker node）和一个Master节点组成。Master节点负责整个集群的管理工作，为集群提供管理接口，并监控和编排集群中的各个工作节点。各节点负责以Pod的形式运行容器，因此，各节点需要事先配置好容器运行依赖到的所有服务和资源，如容器运行环境等。</p>
<p>​    Master节点主要由apiserver、controller-manager和scheduler三个组件，以及一个用于集群状态存储的etcd存储服务组成，每个Node节点则主要包含kubelet、kube-proxy及容器引擎（Docker）等组件。</p>
<p><img src="C:\Users\licr\AppData\Roaming\Typora\typora-user-images\1563447759383.png" alt="1563447759383"></p>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><ol>
<li><p><strong>API Server</strong></p>
<p>​    API Server负责输出RESTful风格的Kubernetes API，它是发往集群的所有REST操作命令的接收点，并负责接收、校验并响应所有的REST请求，结果状态被持久存储于etcd中。因此，API Server是整个集群的网关。</p>
</li>
<li><p><strong>集群状态存储(etcd)</strong></p>
<p>​    Kubernetes集群的所有状态信息都需要持久存储于存储系统etcd中，etcd是独立的服务组件，并不属于Kubernetes集群自身。生产环境中应该以etcd集群的方式运行以确保其服务可用性</p>
</li>
<li><p><strong>控制器管理器（Controller Manager）</strong></p>
<p>​    Kubernetes中，集群级别的大多数功能都是由几个被称为控制器的进程执行实现的，这几个进程被集成于kube-controller-manager守护进程中。由控制器完成的功能主要包括生命周期功能（垃圾回收等）和API业务逻辑（Pod扩展等）。</p>
</li>
<li><p><strong>调度器（Scheduler）</strong></p>
<p>​    API Server确认Pod对象的创建请求之后，便需要由Scheduler根据集群内各节点的可用资源状态，以及要运行的容器的资源需求做出调度决策。Kubernetes支持自定义调度器。</p>
</li>
</ol>
<a id="more"></a>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ol>
<li><p><strong>kubelet</strong></p>
<p>​    kubelet是运行于工作节点之上的守护进程，它从API Server接收关于Pod对象的配置信息并确保它们处于期望的状态。kubelet会在API Server上注册当前工作节点，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点的资源占用状况。</p>
</li>
<li><p><strong>kube-proxy</strong></p>
<p>​    kube-proxy守护进程，它能够按需为Service资源对象生成iptables或ipvs规则，从而捕获访问当前Service的ClusterIP的流量并将其转发至正确的后端Pod对象。</p>
</li>
</ol>
<h3 id="核心附件"><a href="#核心附件" class="headerlink" title="核心附件"></a>核心附件</h3><ol>
<li><p><strong>KubeDNS</strong></p>
<p>​    在Kubernetes集群中调度运行提供DNS服务的Pod，同一集群中的其他Pod可使用此DNS服务解决主机名。</p>
</li>
<li><p><strong>Kubernetes Dashboard</strong></p>
<p>​    基于Web UI进行集群管理。    </p>
</li>
</ol>
<h2 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h2><p>​    我们可以把API Server类比成一个存储对象的数据库系统，它向客户端提供了API，并负责存储由用户创建的各种资源对象，基于各对象的当前状态如何才能符合用户期望的状态，则需要交由另一类称为控制器的组件来负责完成。Kubernetes提供了众多的控制器来管理各种类型的资源，每一个控制器对象都可以通过内部的和解循环（reconciliation loop），不间断地监控着由其负责的所有资源并确保其处于或不断地逼近用户定义的目标状态。</p>
<p>​    Pod控制器资源通过持续性地监控集群中运行着的Pod资源对象来确保受其管控的资源严格符合用户期望的状态，例如资源副本的数量要精确符合期望等。通常，一个Pod控制器资源至少应该包含三个基本的组成部分。</p>
<ul>
<li>标签选择器：匹配并关联Pod资源对象，并据此完成受其管控的Pod资源计数。</li>
<li>期望的副本数：期望在集群中精确运行着的Pod资源的对象数量。</li>
<li>Pod模板：用于新建Pod资源对象的Pod模板资源。</li>
</ul>
<h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>​    ReplicaSet（简称RS）是Pod控制器类型的一种实现，用于确保由其管控的Pod对象副本数在任.时刻都能精确满足期望的数量。ReplicaSet控制器资源启动后会查找集群中匹配其标签选择器的Pod资源对象，当前活动对象的数量与期望的数量不吻合时，多则删除，少则通过Pod模板创建以补充，等Pod资源副本数量符合期望值后即进行下一轮和解循环。</p>
<p>​    然而，有时我们需要对RS进行改动，常见的有改动Pod模板及修改副本数量。改动Pod模板的定义对已经创建完成的活动对象失效，但在用户逐个自动关闭其旧版本的Pod资源后就能以新代旧，实现控制器下应用版本的滚动升级。修改副本的数量也就意味着应用规模的扩展（提升期望的副本数量）或收缩（降低期望的副本数量）。</p>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>​    它构建于ReplicaSet控制器之上，可为Pod和ReplicaSet资源提供声明式更新。相比较而言，Pod和ReplicaSet是较低级别的资源，它们很少被直接使用。Deployment支持事件和状态查看，回滚，版本记录，暂停和启动，多种自动更新方案。</p>
<h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>​    利用Deployment等其他控制器创建的pod实例副本没有本质的差别，互相之间也没有联系。然而对于很多分布式的应用来说，应用本身就是分布式的集群，各应用实例彼此之间存在着关联关系，甚至是角色的相关性，其中每个实例都有其自身的独特性而无法轻易由其他实例所取代。StatefulSet专门用来管理有状态应用。设计有状态应用程序时需要着重考虑的另一个问题是数据持久存储的位置，在应用程序所在的节点发生故障后依然需要确保数据可被访问的场景就需要一个外部的持久存储系统，否则使用节点本地存储卷即可。</p>
<p>​    StatefulSet支持每个Pod对象一个专有索引、有序部署、有序终止、固定的标识符及固定的存储卷等特性。一般来说，一个典型、完整可用的StatefulSet通常由三个组件构成：Headless Service、StatefulSet和volumeClaimTemplate。</p>
<h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><p>​    用于在集群中的全部节点上同时运行一份指定的Pod资源副本，后续新加入集群的工作节点也会自动创建一个相关的Pod对象，当从集群移除节点时，此类Pod对象也将被自动回收且无须重建。管理员也可以使用节点选择器及节点标签指定仅在部分具有特定特征的节点上运行指定的Pod对象。</p>
<p>​    DaemonSet的用途主要有：运行集群存储的守护进程，如在各个节点上运行glusterd或ceph。在各个节点上运行日志收集守护进程，如fluentd和logstash。在各个节点上运行监控系统的代理守护进程，如Prometheus Node<br>Exporter、collectd、Datadog agent、New Relic agent或Ganglia gmond等。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>​    与Deployment及DaemonSet控制器管理的守护进程类的服务应用不同的是，Job控制器用于调配Pod对象运行一次性任务，容器中的进程在正常运行结束后不会对其进行重启，而是将Pod对象置于“Completed”（完成）状态。若容器中的进程因错误而终止，则需要依配置确定重启与否，未运行完成的Pod对象因其所在的节点故障导致意外终止后会被重新调度。</p>
<h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><p>​    CronJob控制器用于管理Job控制器资源的运行时间。Job控制器定义的作业任务在其控制器资源创建之后便会立即执，但CronJob可以以类似于Linux操作系统的周期性任务作业计划（crontab）的方式控制其运行的时间点及重复运行的方式。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>​    尽管Pod对象可以拥有IP地址，但此地址无法确保在Pod对象重启或被重建后保持不变，这会为集群中的Pod应用间依赖关系的维护带来麻烦：前端Pod应用基于固定地址持续跟踪后端Pod应用。于是，Service资源被用于在被访问的Pod对象中添加一个有着固定IP地址的中间层，客户端向此地址发起访问请求后由相关的Service资源调度并代理后端的Pod对象。</p>
<p>​    简单来讲，一个Service对象就是工作节点上的一些iptables或ipvs规则，用于将到达Service对象IP地址的流量调度转发至相应的Endpoints对象指向的IP地址和端⼜之上。</p>
<p>​    Service主要有三种常用类型：第一种是仅用于集群内部通信的ClusterIP类型；第二种是接收集群外部请求的NodePort类型，它工作于每个节点的主机IP之上；第三种是LoadBalancer类型，它可以把外部请求负载均衡到多个Node的主机IP的NodePort之上。</p>
<h2 id="存储卷和数据持久化"><a href="#存储卷和数据持久化" class="headerlink" title="存储卷和数据持久化"></a>存储卷和数据持久化</h2><p>​    Pod本身具有生命周期，故其内部运行的容器及其相关数据均无法持久存在。Docker支持配置容器使用存储卷将数据持久存储于容器之外的存储空间中，它们可以是节点文件系统或网络文件系统之上的存储空间。相应地，Kubernetes也支持类似的存储卷功能，不过，其存储卷是与Pod资源绑定而非容器。简单来说，存储卷是定义在Pod资源之上、可被其内部的所有容器挂载的共享目录，它关联在某外部的存储设备之上的存储空间，从而独立于容器运行的文件系统，而数据是否具有持久能力则取决于存储卷本身是否支持持久机制。</p>
<p>​    hostPath属于节点级别的卷类型，POD经过重新调度后无法使用之前的存储数据。要想使用持久类型的存储卷，就得使用网络存储系统，如NFS、Ceph、GlusterFS等，或者云端存储，如gcePersistentDisk，awsElasticBlockStore等。</p>
<p>​    Kubernetes为此专门设计了一种集群级别的资源PersistentVolume（简称PV），它借由管理员配置存储<br>系统，然后由用户通过“persistentVolumeClaim”（简称PVC）存储卷直接申请使用的机制.</p>
<h2 id="kubernetes网络通信"><a href="#kubernetes网络通信" class="headerlink" title="kubernetes网络通信"></a>kubernetes网络通信</h2><h3 id="kubernetes网络模型概述"><a href="#kubernetes网络模型概述" class="headerlink" title="kubernetes网络模型概述"></a>kubernetes网络模型概述</h3><p>​    Kubernetes的网络中主要存在四种类型的通信：同一Pod内的容器间通信、各Pod彼此之间的通信、Pod与Service间的通信，以及集群外部的流量同Service之间的通信。</p>
<h2 id="helm包管理程序"><a href="#helm包管理程序" class="headerlink" title="helm包管理程序"></a>helm包管理程序</h2><h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><p>​    需要注意的是，在实际的应用场景中，在接收到的请求流量负载显著低于或接近于已有Pod副本的整体承载能力时，用户需要手动修改Pod控制器中的期望副本数量以实现应用规模的扩容或缩容。不过，若集群中部署了HeapSter或Prometheus一类的资源指标监控附件时，用户还可以使用“HorizontalPodAutoscaler”（HPA）计算出合适的Pod副本数量，并手动修改Pod控制器中期望的副本数以实现应用规模的动态伸缩，提高集群资源利用率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/kubernetes概念明晰/" data-id="cjyohczkk000q34idcism8hxz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kubernetes/">kubernetes</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/07/04/使用kubeadm搭建kubernetes集群/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">使用kubeadm搭建kubernetes集群</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/leetcode/" style="font-size: 20px;">leetcode</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/29/kubernetes概念明晰/">kubernetes概念明晰</a>
          </li>
        
          <li>
            <a href="/2019/07/04/使用kubeadm搭建kubernetes集群/">使用kubeadm搭建kubernetes集群</a>
          </li>
        
          <li>
            <a href="/2019/05/27/zookeeper浅析/">zookeeper浅析</a>
          </li>
        
          <li>
            <a href="/2019/03/06/leetcode-54-Spiral-Matrix-m/">leetcode-54.Spiral Matrix-m</a>
          </li>
        
          <li>
            <a href="/2019/03/06/leetcode-53-Maximum-Subarray-e/">leetcode-53. Maximum Subarray-e</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>